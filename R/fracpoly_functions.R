
#####################################################################
###### Functions for JAGS modelling of fractional polynomials #######
#####################################################################


#' Prepare JAGS data for fractional polynomial models
#'
#' @param anova A list generated by `anova_data()` from digitized KM plots containing two named elements.
#' `"aggregate"` contains aggregated survival data for use in fractional polynomial models and must have the
#' following columns:
#'
#'   * `spgrp` index for the time interval
#'   * `trialid` index for trial
#'   * `treatment` treatment names (as character), corresponding to values in `trtnames`
#'   * `nevents` the number of events in a time interval
#'   * `natrisk` the number at risk in a time interval
#'   * `time` time at the end of the time interval (I think)
#'   * `length` the length (duration) of the time interval
#'
#' @param trtnames A character vector of treatment names ordered how the treatment codes should be ordered
#'   within the network
#'
#' @importFrom magrittr "%>%"
#'
#' @export
fp_data <- function(anova, trtnames) {

  data <- anova$aggregate

  if (any(is.na(match(trtnames, data$treatment))) | any(is.na(match(data$treatment, trtnames)))) {
    stop("trtnames must match the values in data$treatment")
  }

  # Set study and treatment codes
  codes <- trtnames

  data$txCode <- as.numeric(factor(data$treatment, labels = codes,
                                   levels=codes))

  studynames <- unique(data$trialid)
  data$trialid <- as.numeric(factor(data$trialid, labels=studynames, levels=studynames))


  # Order data (using tidyverse)
  data <- dplyr::arrange(data, trialid, txCode, spgrp)
  #data <- data[order(data$trialid, data$txCode, data$spgrp),]

  #-----------------------------------------------------------------------------
  # Data formatting
  #-----------------------------------------------------------------------------

  # Need to number the treatment arms within each trial
  # data <- data %>%
  #   dplyr::group_by(trialid, spgrp) %>%
  #   dplyr::mutate(arm=seq(dplyr::n()))
  data <- data %>%
    dplyr::group_by(trialid) %>%
    dplyr::mutate(arm=dense_rank(txCode))

  # Drop uneven spgrp within a trial (test if removing makes a difference by using 1st bit of code)
  # data <- data %>%
  #   dplyr::group_by(trialid, spgrp) %>%
  #   dplyr::mutate(drop=dplyr::n())

  # if (any(data$drop==1)) {
  #   warning("Dataset includes trials with only 1 arm")
  # }

  # data <- data %>%
  #   dplyr::group_by(trialid, spgrp) %>%
  #   dplyr::mutate(drop=dplyr::n()) %>%
  #   subset(drop!=1)

  # data <- data %>%
  #   group_by(trialid, txCode, arm) %>%
  #   mutate(drop=n()) %>%
  #   subset(drop!=1)

  # Maxarm
  # data <- data %>%
  #   dplyr::group_by(trialid, spgrp) %>%
  #   dplyr::mutate(maxarm=dplyr::n()) %>%
  #   dplyr::ungroup()
  data <- data %>%
    dplyr::group_by(trialid) %>%
    dplyr::mutate(maxarm=max(arm)) %>%
    dplyr::ungroup()

  # Check all arms coded
  #all(data$arm==1 | data$arm==2 | data$arm==3)

  # Length of time intervals
  data$length <- data$time-data$start

  # na
  temp <- data %>% dplyr::select(trialid, maxarm) %>% unique(.)
  na <- temp$maxarm

  # t
  temp <- data %>% dplyr::select(trialid, txCode) %>% unique(.)
  t <- matrix(nrow=length(na), ncol=max(na))
  for (i in seq_along(unique(temp$trialid))) {
    sub <- temp[temp$trialid==unique(temp$trialid)[i],]
    t[i, 1:nrow(sub)] <-
      sub$txCode
  }

  # Values for multinomial normal prior
  d.mean <- c(0,0,0)
  precarray <- array(c(0.0001, 0, 0,
                       0, 0.0001, 0,
                       0, 0, 0.0001), dim=c(3,3))

  ########### Create JAGS data #########

  jagsdat <- list(s=data$trialid, r=data$nevents, z=data$natrisk, a=data$arm, time=data$time,
                  dt=data$length, N=nrow(data), nt=dplyr::n_distinct(data$treatment), ns=dplyr::n_distinct(data$trialid),
                  mean=d.mean, prec=precarray,
                  t=t,  na=na)

  attributes(jagsdat)$trtnames <- trtnames
  attributes(jagsdat)$studynames <- studynames
  attributes(jagsdat)$ipd <- anova$ipd

  return(jagsdat)
}





#' Plot posterior means of residual deviance contributions
#'
#' Plots posterior means of residual deviance contributions or dev-dev plots (if two models are specified)
#'
#' @param jagsmod1 Object of class `rjags` that includes monitored `dev` nodes
#' @param jagsmod2 Object of class `rjags` that includes monitored `dev` nodes (default is `NULL` but if model
#' is included then dev-dev plot is created)
#' @param vline Can take either `"arm"` or `"study"` to indicate whether vertical dashed lines should indicate change in
#' arm or study respectively. Can be set as `NULL` to not plot any (will be set to `NULL` for dev-dev plots)
#'
#' @details
#' Note that for dev-dev plots to be created the model must have the same number of deviance contributions. I.e. the
#' likelihood and data used must be the same. Cannot be used to compare different datasets or likelihoods.
#'
#' @export
devplot <- function(jagsmod1, jagsmod2=NULL, vline="arm") {

  if (!"rjags" %in% class(jagsmod1)) {
    stop("jagsmod1 is not an object of class rjags")
  }
  if (!"dev" %in% names(jagsmod1$BUGSoutput$mean)) {
    stop("deviance contributions not monitored in jagsmod1")
  }

  jagsdat <- jagsmod1$model$data()

  studynames <- attributes(jagsmod1)$studynames

  dev.df <- data.frame(dev1=jagsmod1$BUGSoutput$mean$dev,
                       study=factor(studynames[jagsdat$s]),
                       arm=jagsdat$a,
                       N=1:jagsdat$N)

  # Powers info
  P1 <- jagsmod1$model$data()$P1
  P2 <- jagsmod1$model$data()$P2

  info1 <- paste0("(P1 = ", P1,
                  ifelse(!is.null(P2), paste0(", P2 = ", P2, ")"), ")"))

  capt <- paste0("Total residual deviance for jagsmod1: ", round(jagsmod1$BUGSoutput$mean$totresdev,1))

  # Check where there are observations that change arm/study
  cuts <- vector()
  start <- 1 # Assumes trialid and arm are numeric
  for (i in seq_along(dev.df$N)) {
    if (dev.df[[vline]][i]!=dev.df[[vline]][start]) {
      cuts <- append(cuts, dev.df$N[i])
      start <- dev.df$N[i]
    }
  }


  if (!is.null(jagsmod2)) {
    if (!"rjags" %in% class(jagsmod2)) {
      stop("jagsmod2 is not an object of class rjags")
    }
    if (!"dev" %in% names(jagsmod2$BUGSoutput$mean)) {
      stop("deviance contributions not monitored in jagsmod2")
    }

    dev.df$dev2 <- jagsmod2$BUGSoutput$mean$dev

    # Powers info
    P1 <- jagsmod2$model$data()$P1
    P2 <- jagsmod2$model$data()$P2

    info2 <- paste0("(P1 = ", P1,
                   ifelse(!is.null(P2), paste0(", P2 = ", P2, ")"), ")"))

    capt2 <- paste0("Total residual deviance for jagsmod2: ", round(jagsmod2$BUGSoutput$mean$totresdev,1))
    capt <- paste(capt, capt2, sep="\n")

    g <- ggplot2::ggplot(data=dev.df, ggplot2::aes(x=dev1, y=dev2)) +
      ggplot2::geom_point(aes(color=study, shape=study)) +
      ggplot2::xlab(paste("Residual deviance for jagsmod1", info1)) +
      ggplot2::ylab(paste("Residual deviance for jagsmod2", info2))

  } else {

    g <- ggplot2::ggplot(data=dev.df, ggplot2::aes(x=N, y=dev1)) +
      ggplot2::geom_point(aes(color=study, shape=study)) +
      ggplot2::geom_vline(xintercept=cuts, linetype="dashed") +
      ggplot2::ylab(paste("Residual deviance for jagsmod1", info1)) +
      ggplot2::xlab("Observation number")

  }

  g <- g + labs(caption=capt) +
    theme_bw()

  return(g)
}







#' Takes IPD data and returns aggregated time interval data
#'
#' Takes a generated dataset and formats the data ready to apply the anova parameterisation
#'
#' @param timepoints A numeric vector indicating the time intervals to use for aggregating
#' @param df A data frame of IPD KM data containing the variables:
#'
#' * `time` Numeric time at which event/censoring occured
#' * `event` Binary indicating whether an event (`1`) or censoring (`0`) occured
#' * `treatment` Factor variable for treatment name
#' * `study` Factor variable for study name
#'
#' @export
anova_data <- function(timepoints, df){

  # Split the data at timepoints
  df2 <- survival::survSplit(Surv(time, event) ~., data=df,
                   cut=timepoints[2:length(timepoints)], episode ="timegroup")

  # Calculate offset
  df2$y <- df2$time - df2$tstart

  # Add a variable that equals one for all patients - this is so the number at risk
  # can be calculated when we collapse the data
  df2$n <- 1

  # Collapse data
  df3 <- doBy::summaryBy(y + event + n ~ timegroup + treatment + study, FUN=c(sum, max), data=df2)
  df3 <- subset(df3, select=-c(event.max, n.max))
  names(df3) <- c("spgrp", "treatment", "trialid", "y", "nevents", "natrisk", "y.max")


  # Add in a start time variable
  df3$start <- NA
  for(i in unique(df3$spgrp)){
    df3$start[df3$spgrp==i] <- timepoints[i]
  }

  # Add in a time variable (i.e. how long since time 0 to max value of y for each row)
  df3$time <- df3$start + df3$y.max

  # Return the formatted dataset
  out <- list("aggregate"=df3, "ipd"=df)
  return(out)

}







#' Create initial values for model
#'
#' Assumes 3 chains
#'
#' @param ns An integer for the number of studies in the analysis
#' @param nt An integer for the number of treatments in the analysis
#' @param polyorder Takes 1 for 1st order and 2 for 2nd order fractional polynomials
#' @param seed Can be set to `NULL` if no seed is desired
#'
#' @export
fp_geninits <- function(ns, nt, polyorder=1, seed=890421) {

  if (!is.null(seed)) {
    set.seed <- seed
  }

  init1 <- list()
  init1$d <- matrix(nrow=nt, ncol=polyorder+1, 0.1)
  init1$mu <- matrix(nrow=ns, ncol=polyorder+1,
                     round(runif(ns*(polyorder+1), 0.1, 0.6), 1))
  init1$d[1,] <- NA

  init2 <- list()
  init2$d <- matrix(nrow=nt, ncol=polyorder+1, 0.2)
  init2$mu <- matrix(nrow=ns, ncol=polyorder+1,
                     round(runif(ns*(polyorder+1), -0.2, 0.7), 1))
  init2$d[1,] <- NA

  init3 <- list()
  init3$d <- matrix(nrow=nt, ncol=polyorder+1, round(runif(nt*(polyorder+1), -0.1,0.1),1))
  init3$mu <- matrix(nrow=ns, ncol=polyorder+1,
                     round(runif(ns*(polyorder+1), -0.1, 0.7), 1))
  init3$d[1,] <- NA

  return(list(init1,
              init2,
              init3))
}





#' Calculate time-varying hazard ratios (HR)
#'
#' @param jagsmod an object of class `"rjags"` that contains the results of a
#' fractional polynomial model.
#' @param times a vector of times at which to estimate time-varying HRs
#' @param eform whether results should be on log (`FALSE`) or exponentiated onto
#' natural (`TRUE`) scale.
#'
#' @export
hrcalc <- function(jagsmod,
                   times=seq(1,60, length.out=100),
                   eform=TRUE) {

  if (!"rjags" %in% class(jagsmod)) {
    stop("jagsmod must be an object of class rjags")
  }
  if (!all(c("d") %in% jagsmod$parameters.to.save)) {
    stop("d must be monitored in jagsmod")
  }

  # Check attributes
  if (is.null(attributes(jagsmod)$trtnames)) {
    stop("jagsmod must have trtnames and studynames attributes")
  }
  if (is.null(attributes(jagsmod)$studynames)) {
    stop("jagsmod must have trtnames and studynames attributes")
  }

  if (eform==TRUE) {
    message("Outputs will be on HR scale")
  } else {
    message("Outputs will be on log-HR scale")
  }

  jagsdat <- jagsmod$model$data()
  sims.list <- jagsmod$BUGSoutput$sims.list

  d  <- sims.list$d

  exponents <- jagsdat$P1
  if (!is.null(jagsdat$P2)) {
    exponents <- c(exponents, jagsdat$P2)
  }

  out.df <- data.frame()
  for (k in 1:jagsdat$nt) {
    for (c in 1:jagsdat$nt) {
      beta <- d[,k,] - d[,c,]

      loghr <- get_fp(x = times,
                       params = beta,
                       exponents = exponents)

      if (eform==TRUE) {
        loghr <- exp(loghr)
      }

      loghr_sum <- t(apply(loghr, MAR = 1, FUN = mcmc_sum))
      temp <- data.frame(trt1=k,
                         trt2=c,
                         time=times,
                         loghr_sum
                         )

      out.df <- rbind(out.df, temp)
    }
  }
  names(out.df) <- c("trt1", "trt2", "time", "mean", "sd", "2.5%", "50%", "97.5%")

  # Assign trtnames to out.df
  trtnames <- attributes(jagsmod)$trtnames
  out.df$trt1 <- trtnames[out.df$trt1]
  out.df$trt2 <- trtnames[out.df$trt2]

  out <- list(summary=out.df,
              P1=jagsmod$model$data()$P1, P2=jagsmod$model$data()$P2)

  # Set attributes to match those of jagsdat
  attributes(out)$trtnames <- attributes(jagsmod)$trtnames
  attributes(out)$studynames <- attributes(jagsmod)$studynames
  attributes(out)$eform <- eform

  class(out) <- "hazard.ratios"

  return(out)
}



#' @describeIn hrcalc Plot time-varying HRs
#'
#' @param hr An object of class `"hazard.ratios"` containing the output of `hrcalc()`
#' @param reftrt The name of the reference treatment against which HRs should be plotted. Must match
#' a name in `attr(hr, "trtnames")`
#'
#' @export
plot.hazard.ratios <- function(hr, reftrt) {
  if (!"hazard.ratios" %in% class(hr)) {
    stop("hr must be an object of class 'hazard.ratios' generated by hrcalc()")
  }

  out.df <- hr$summary

  trtnames <- attr(hr, "trtnames")

  out.df$trt1 <- factor(out.df$trt1, labels=trtnames, levels=trtnames)

  # Ensure palette is sufficiently large
  all.cols <- RColorBrewer::brewer.pal(9, "Set1")
  all.cols <- c(all.cols, RColorBrewer::brewer.pal(4, "Set2"))

  out.df <- subset(out.df, trt2==reftrt)
  cols <- all.cols[unique(as.numeric(out.df$trt1))]

  g <- ggplot2::ggplot(out.df, ggplot2::aes(x=time, ymin=`97.5%`, ymax=`2.5%`, y=`50%`,
                          color=trt1, fill=trt1, linetype=trt1)) +
    ggplot2::geom_line() +
    ggplot2::geom_ribbon(alpha=0.3, color=NA) +
    ggplot2::xlab("Time") +
    ggplot2::ylab(ifelse(attributes(hr)$eform, "HR", "log-HR")) +
    ggplot2::theme_bw() +
    ggplot2::ggtitle(paste0("Time-varying relative effects vs treatment ", unique(out.df$trt2))) +
    ggplot2::scale_fill_manual(name = "Treatment", values=cols) +
    ggplot2::scale_color_manual(name = "Treatment", values=cols) +
    ggplot2::scale_linetype_discrete(name = "Treatment") +
    ggplot2::labs(caption=paste0("Fractional polynomial; P1 = ", hr$P1, ifelse(!is.null(hr$P2), paste0(", P2 = ", hr$P2), "")))

  return(g)
}




#' Predict survival quantities
#'
#' Outputs survival probabilities (`"S"`), mortality probabilities (`"mort"`),
#' cumulative hazards (`"cumhaz"`) and hazards (`"haz"`).
#'
#' @inheritParams hrcalc
#' @inheritParams weight_shared_d
#' @param refstudy Name of the study to use as reference when making predictions. If
#' `refmod=jagsmod` (the default) then `refstudy` must match a name
#' in `attr(jagsmod, "studynames")`
#' @param refmod An object of class `"rjags"` that contains a fractional polynomial
#' model for the reference arm. `mu` parameters must be monitored, to which
#' fractional polynomial relative effects (`d`) from `jagsmod` can be
#' applied. The default is to use `jagsmod` as the reference model, in which case a
#' choice of reference study must be specified using `refstudy`.
#' @param n.mcmc integer to indicate the number of MCMC samples to draw (without replacement). Note that sampling
#' is random (though is the same across parameters to preserve within-sample correlation). Speeds up computation,
#' though will result in higher MCMC error.
#'
#' @export
survcalc <- function(jagsmod, refstudy, refmod=jagsmod,
                     times=seq(1,60, length.out=100),
                     n.mcmc=NULL, d.weight=NULL) {

  if (!"rjags" %in% class(jagsmod)) {
    stop("jagsmod must be an object of class rjags")
  }
  if (!"rjags" %in% class(refmod)) {
    stop("refmod must be an object of class rjags")
  }
  if (!all(c("d", "mu") %in% jagsmod$parameters.to.save)) {
    stop("d and mu must be monitored in jagsmod")
  }

  jagsdat <- jagsmod$model$data()
  sims.list <- jagsmod$BUGSoutput$sims.list

  if (is.null(jagsdat$P2)) {
    polyorder <- 1
  } else {
    polyorder <- 2
  }

  # Speeds up computation
  # And ensures the largest MCMC object samples are fully used
  if (!is.null(n.mcmc)) {
    mcmc.index <- sample(1:jagsmod$BUGSoutput$n.sims, size=n.mcmc)
    matsize <- n.mcmc

    mcmc.index.jags <- mcmc.index
    mcmc.index.ref <- mcmc.index

  } else {
    mcmc.index.jags <- 1:jagsmod$BUGSoutput$n.sims
    mcmc.index.ref <- 1:refmod$BUGSoutput$n.sims

    if (jagsmod$BUGSoutput$n.sims > refmod$BUGSoutput$n.sims) {
      mcmc.index.ref <- c(mcmc.index.ref,
                          sample(1:refmod$BUGSoutput$n.sims,
                                 size=jagsmod$BUGSoutput$n.sims - refmod$BUGSoutput$n.sims)
                          )
      matsize <- jagsmod$BUGSoutput$n.sims
    } else if (jagsmod$BUGSoutput$n.sims < refmod$BUGSoutput$n.sims) {
      mcmc.index.jags <- c(mcmc.index.jags,
                          sample(1:jagsmod$BUGSoutput$n.sims,
                                 size=refmod$BUGSoutput$n.sims - jagsmod$BUGSoutput$n.sims)
      )
      matsize <- refmod$BUGSoutput$n.sims
    } else {
      matsize <- jagsmod$BUGSoutput$n.sims
    }
    n.sims <- max(jagsmod$BUGSoutput$n.sims, refmod$BUGSoutput$n.sims)
  }

  # Get index of reference study
  if (!identical(jagsmod, refmod)) {
    message("Model for reference curve is different to the treatment effect model")
  }

  refstudy.ind <- which(attr(refmod, "studynames") %in% refstudy)
  if (length(refstudy.ind)==0) {
    if (dim(refmod$BUGSoutput$sims.list$mu)[2]==1) {
      refstudy.ind <- 1
    } else {
      stop("refstudy is not a named study in attr(refmod, 'studynames')")
    }
  }

  reftrt <- jagsdat$t[refstudy.ind,1]

  haz.df <- data.frame()
  cumhaz.df <- data.frame()
  mort.df <- data.frame()
  S.df <- data.frame()

  mu <- refmod$BUGSoutput$sims.list$mu[, refstudy.ind, ]
  d  <- sims.list$d

  # Weight treatment effects
  if (!is.null(d.weight)) {
    d <- weight_shared_d(jagsmod, d.weight=d.weight)
  }

  exponents <- jagsdat$P1
  if (!is.null(jagsdat$P2)) {
    exponents <- c(exponents, jagsdat$P2)
  }

  #dt <- diff(c(0,times))

  #dt <- rep(1, length(times))
  dt <- diff(seq(0,max(times), length.out=length(times)+1))

  for (k in 1:jagsdat$nt) {

    beta <- mu[mcmc.index.ref,] +
      (d[mcmc.index.jags,k,] - d[mcmc.index.jags,reftrt,])

    loghaz <- get_fp(x = times,
                     params = beta,
                     exponents = exponents)

    haz <- exp(loghaz)

    dH <- dt * haz # approximate the cumulative hazard (for every MCMC iteration); first calculate the incerments over every interval, then sum up
    H  <- apply(dH, MAR = 2, cumsum)
    #H  <- apply(haz, MAR = 2, cumsum)
    mort <- 1-exp(-H)
    S  <- exp(-H)

    # Create data frames
    S_sum <- t(apply(S, MAR = 1, FUN = mcmc_sum))
    temp <- data.frame(time = times,
                       treatment = k,
                       S_sum)

    # Add survival at time=0
    temp2 <- data.frame(time = 0,
                        treatment = k,
                        t(apply(matrix(1,nrow=1, ncol=1), MAR = 1, FUN = mcmc_sum)))
    temp <- rbind(temp2, temp)

    S.df <- rbind(S.df, temp)

    mort_sum <- t(apply(mort, MAR = 1, FUN = mcmc_sum))
    temp <- data.frame(time = times,
                       treatment = k,
                       mort_sum)
    mort.df <- rbind(mort.df, temp)

    cumhaz_sum <- t(apply(H, MAR = 1, FUN = mcmc_sum))
    temp <- data.frame(time = times,
                       treatment = k,
                       cumhaz_sum)
    cumhaz.df <- rbind(cumhaz.df, temp)

    haz_sum <- t(apply(haz, MAR = 1, FUN = mcmc_sum))
    temp <- data.frame(time = times,
                       treatment = k,
                       haz_sum)
    haz.df <- rbind(haz.df, temp)
  }

  names(haz.df) <- names(cumhaz.df) <- names(mort.df) <- names(S.df) <-
    c("time", "treatment", "mean", "sd", "2.5%", "50%", "97.5%")

  # Add treatment names
  trtnames <- attr(jagsmod, "trtnames")
  haz.df$treatment <- trtnames[haz.df$treatment]
  cumhaz.df$treatment <- trtnames[cumhaz.df$treatment]
  mort.df$treatment <- trtnames[mort.df$treatment]
  S.df$treatment <- trtnames[S.df$treatment]

  out <- list(haz=haz.df, cumhaz=cumhaz.df, mort=mort.df, S=S.df,
              P1=jagsdat$P1, P2=jagsdat$P2)

  attr(out, "refstudy") <- refstudy
  attr(out, "trtnames") <- trtnames
  attr(out, "studynames") <- attr(jagsmod, "studynames")
  attr(out, "ipd") <- attr(jagsmod, "ipd")
  class(out) <- "surv.predicts"

  return(out)
}





#' Weight treatment effects in shared parameter model by proportion of population
#'
#' @inheritParams survcalc
#' @param d.weight A numeric weighting (between 0 and 1) to apply to treatment
#' effects for a shared parameter model (e.g. separate treatment effects for
#' histology). Default (`NULL`) is not to apply any weighting.
#'
weight_shared_d <- function(jagsmod, d.weight) {

  jagsdat <- jagsmod$model$data()
  d <- jagsmod$BUGSoutput$sims.list$d

  if (is.null(jagsdat$P2)) {
    polyorder <- 1
    if (dim(jagsmod$BUGSoutput$sims.list$d)[3]>2) {
      if (is.null(d.weight)) {
        warning("Dimensions of d indicate shared parameter model but d.weight is NULL")
      }
    }
  } else {
    polyorder <- 2
    if (dim(jagsmod$BUGSoutput$sims.list$d)[3]>3) {
      if (is.null(d.weight)) {
        warning("Dimensions of d indicate shared parameter model but d.weight is NULL")
      }
    }
  }

  if (length(d.weight)>1) {
    stop("d.weight must be length 1")
  }

  # Get parameter indices
  dparams <- 1:dim(jagsmod$BUGSoutput$sims.list$d)[3]
  wparams <- dparams[-c(1:(polyorder+1))]

  # Apply weightings
  for (param in seq_along(wparams)) {
    d[,,param] <- (d[,,param] * (1-d.weight)) + (d[,,wparams[param]] * d.weight)
  }

  # Drop additional indices
  d <- d[,,-wparams]

  return(d)
}





#' @describeIn survcalc Plot survival predictions
#'
#' @param surv An object of class `"surv.predicts"` generated by `survcalc()`
#' @param quantity specifies the quantity to be plotted. Can be either `"S"` for survival (note that S is upper case),
#' `"mort"` for mortality, `"haz"` for hazards, `"cumhaz"` for cumulative hazards.
#' @param treats treatments to plot (as integers). Default plots them all
#' @param plotinterval indicates whether to plot 95 percent CrI
#' @param overlay.km Indicates whether Kaplan Meier data for the reference study should be plotted
#'
#' @export
plot.surv.predicts <- function(surv, quantity="S",
                               treats=attr(surv, "trtnames"),
                               plotinterval=TRUE,
                               overlay.km=FALSE
                               ) {
  if (!"surv.predicts" %in% class(surv)) {
    stop("surv must be an object of class 'surv.predicts' generated by survcalc()")
  }
  if (overlay.km==TRUE & quantity!="S") {
    stop("Plotting IPD Kaplan-Meier data is only possible if quantity='S'")
  }

  out.df <- surv[[quantity]]

  trtnames <- attr(surv, "trtnames")
  out.df$treatment <- factor(out.df$treatment, labels=trtnames, levels=trtnames)

  # Define colours
  all.cols <- RColorBrewer::brewer.pal(9, "Set1")
  all.cols <- c(all.cols, RColorBrewer::brewer.pal(4, "Set2"))

  # Subset by treatments
  out.df <- subset(out.df, treatment %in% treats)
  cols <- all.cols[unique(as.numeric(out.df$treatment))]

  capt <- paste0("Fractional polynomial; P1 = ", surv$P1, ifelse(!is.null(surv$P2), paste0(", P2 = ", surv$P2), ""))
  capt <- paste(capt, paste("Reference study:", attr(surv, "refstudy")), sep="\n")

  g <- ggplot2::ggplot(out.df, ggplot2::aes(x=time, ymin=`97.5%`, ymax=`2.5%`, y=`50%`,
                          color=treatment, fill=treatment, linetype=treatment)) +
    ggplot2::geom_line() +
    ggplot2::xlab("Time") + ggplot2::ylab(quantity) +
    ggplot2::theme_bw() +
    ggplot2::scale_fill_manual(name = "Treatment", values=cols) +
    ggplot2::scale_color_manual(name = "Treatment", values=cols) +
    ggplot2::scale_linetype_discrete(name = "Treatment") +
    ggplot2::labs(caption=capt)

  if (plotinterval) {
    g <- g + ggplot2::geom_ribbon(alpha=0.3)
  }

  if (overlay.km==TRUE) {

    # Get IPD data into correct format
    ipd <- attr(surv, "ipd")
    trtnames <- attr(surv, "trtnames")
    ipd$treatment <- factor(ipd$treatment, labels=trtnames, levels=trtnames)

    sub <- subset(ipd, study==attr(surv, "refstudy") & treatment %in% treats)

    # Add KM plot
    g <- g + geom_km(sub)

    # kmdat <- survival::survfit(Surv(time, event) ~ treatment, data=sub, type="kaplan-meier",)
    #
    # if (length(treats)>1) {
    #   trtvec <- vector()
    #   for (i in seq_along(unique(sub$treatment))) {
    #     trtvec <- append(trtvec, rep(unique(sub$treatment)[i], kmdat$strata[i]))
    #   }
    # } else {
    #   trtvec <- rep(unique(sub$treatment),length(kmdat$time))
    # }
    #
    # kmdat <- cbind(kmdat$time, kmdat$surv, trtvec)
    #
    # kmdat <- as.data.frame(kmdat)
    #
    # names(kmdat) <- c("time", "50%", "treatment")
    # kmdat$treatment <- factor(kmdat$treatment, labels=trtnames, levels=1:length(trtnames))
    # kmdat[["2.5%"]] <- 0
    # kmdat[["97.5%"]] <- 0
    #
    # # Add km plot
    # g <- g + ggplot2::geom_step(data=kmdat, ggplot2::aes(x=time, y=`50%`), color="black", linetype="solid")
  }

  return(g)
}



#' Adds a geom-ish object for Kaplan-Meier data
#'
#' Function has been frankensteined from multinma (https://github.com/dmphillippo/multinma/tree/develop)
#'
#' @param ... Additional arguments passed to [survival::survfit()]
#' @param curve_args Optional list of arguments to customise the curves plotted
#' with [ggplot2::geom_step()]
#' @inheritParams anova_data
#'
#' @export
geom_km <- function(df, curve_args = list(), ...) {
  dots <- list(...)

  # Get KM fits
  # trtnames <- attr(surv, "trtnames")
  # ipd$treatment <- factor(ipd$treatment, labels=trtnames, levels=trtnames)

  kmdat <- df %>%
    dplyr::group_by(study, treatment) %>%
    dplyr::group_modify(~dplyr::as_tibble(unclass(
      do.call(survival::survfit, rlang::dots_list(formula = Surv(time, event) ~ 1, !!! dots,  data = ., .homonyms = "last"))
    )[c("time", "n.censor", "surv", "std.err", "upper", "lower")])) %>%
    # Add S(0) = 1
    dplyr::group_modify(~dplyr::add_row(., time = 0, n.censor = 0, surv = 1, std.err = 0, upper = 1, lower = 1, .before = 0)) %>%
    dplyr::mutate(treatment = treatment, refstudy = study)

  #return(kmdat)

  # Set geom args
  curve_args <- rlang::dots_list(ggplot2::aes(x = kmdat$time, y = kmdat$surv,
                                              #color=kmdat$treatment,
                                              group = interaction(kmdat$refstudy, kmdat$treatment)),
                                 data = kmdat,
                                 !!! curve_args,
                                 linewidth = 0.5,
                                 color="black",
                                 inherit.aes=FALSE,
                                 .homonyms = "first")

  # cens_args <- rlang::dots_list(ggplot2::aes(x = kmdat$time, y = kmdat$surv, colour = kmdat$treatment, group = interaction(kmdat$refstudy, kmdat$treatment)),
  #                               data = dplyr::filter(kmdat, .data$n.censor >= 1),
  #                               !!! cens_args,
  #                               stroke = 0.25, shape = 3,
  #                               .homonyms = "first")

  # Output ggplot geoms
  list(do.call(ggplot2::geom_step, args = curve_args))#, do.call(ggplot2::geom_point, args = cens_args))
}






#' Plots survival predictions for each study as baseline for comparison with Kaplan-Meier
#'
#' Can be used to assess model fit
#'
#' @inheritParams hrcalc
#' @inheritParams plot.surv.predicts
#' @inheritParams survcalc
#' @param studies A character vector of study names. Must be a subset of
#' `attr(jagsmod, "studynames")`.
#' @param d.weights A numeric vector containing weightings (between 0 and 1)
#' for each study to apply to treatment
#' effects for a shared parameter model (e.g. separate treatment effects for
#' histology). Default (`NULL`) is not to apply any weighting. Order of weights
#' must correspond to the studies in `attr(jagsmod, "studynames")`
#'
#' @export
studykm_survplot <- function(jagsmod,
                             #times=seq(1,60, length.out=100),
                             studies=attr(jagsmod, "studynames"),
                             d.weights=NULL,
                             plotinterval=TRUE
                             ) {

  quantity <- "S"
  ipd <- attributes(jagsmod)$ipd

  if (!all(studies %in% unique(ipd$study))) {
    stop("studies must be a subset of attr(jagsmod, 'studynames')")
  }

  if (!is.null(d.weights)) {
    if (length(d.weights)!=length(unique(ipd$study))) {
      stop("length(d.weights) must be equal to the number of studies in the dataset")
    }
  }

  # Create data frame of survival predictions for each reference study
  pb <- utils::txtProgressBar(min = 0,      # Minimum value of the progress bar
                              max = dplyr::n_distinct(ipd$study), # Maximum value of the progress bar
                              style = 3)   # Character used to create the bar

  plot.df <- data.frame()
  for (s in seq_along(studies)) {
    study <- studies[s]

    surv <- survcalc(jagsmod, times=seq(1, max(ipd$time[ipd$study==study]), length.out = 100),
                     refstudy=study, d.weight=d.weights[s])

    # Only show survival predictions for treatments within study
    subtrt <- unique(ipd$treatment[ipd$study==study])

    surv <- surv$S %>%
      subset(treatment %in% subtrt) %>%
      dplyr::mutate(refstudy=study)

    plot.df <- rbind(plot.df, surv)

    setTxtProgressBar(pb, s)
  }


  ##### Create plot #####

  jagsdat <- jagsmod$model$data()
  trtnames <- attr(jagsmod, "trtnames")
  plot.df$treatment <- factor(plot.df$treatment, labels=trtnames, levels=trtnames)
  plot.df$refstudy <- factor(plot.df$refstudy)

  # Define colours
  all.cols <- RColorBrewer::brewer.pal(9, "Set1")
  all.cols <- c(all.cols, RColorBrewer::brewer.pal(4, "Set2"))

  cols <- all.cols[1:length(trtnames)]

  # Subset by treatments
  capt <- paste0("Fractional polynomial; P1 = ", jagsdat$P1, ifelse(!is.null(jagsdat$P2), paste0(", P2 = ", jagsdat$P2), ""))

  g <- ggplot2::ggplot(plot.df, ggplot2::aes(x=time, ymin=`97.5%`, ymax=`2.5%`, y=`50%`,
                                            color=treatment, fill=treatment, linetype=treatment)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~refstudy, scales = "free_x") +
    ggplot2::xlab("Time") + ggplot2::ylab(quantity) +
    ggplot2::theme_bw() +
    ggplot2::scale_fill_manual(name = "Treatment", values=cols) +
    ggplot2::scale_color_manual(name = "Treatment", values=cols) +
    ggplot2::scale_linetype_discrete(name = "Treatment") +
    ggplot2::labs(caption=capt)

  if (plotinterval) {
    g <- g + ggplot2::geom_ribbon(alpha=0.3)
  }

  return(g)
}





#' Posterior summaries for MCMC
#'
#' @param mcmc A numeric vector of MCMC samples (can be a subset of an array/matrix)
#'
#' Returns a vector
#'
mcmc_sum <- function(mcmc) {
  mean <- mean(mcmc)
  sd <- stats::sd(mcmc)
  quants <- stats::quantile(mcmc, probs=c(0.025,0.5,0.975))

  return(c(mean, sd, quants))
}




#' Runs multiple fractional polynomial models
#'
#' Runs multiple fractional polynomial models with various power combinations
#' and can save resulting models. Allows user to set up multiple models to run
#' back to back (so you can go away and have lunch/sleep/whisky).
#'
#' @param jagsdat A list of data to be read by the model (ideally generated by `fp_data()`).
#'   Must have been generated for the same fractional polynomial model order (`polyorder=1` or `polyorder=2`)
#'   as the set of models to run.
#' @param powers A sequence of fractional polynomial powers to run models for. Note that for 2nd order models
#'   all combinations of powers will be run (i.e. lots of models - length(powers) permute 2).
#' @param jagsfile The location of a JAGS model saved as a `.jags` file on which to run
#' the sequence of fractional polynomial models. The default `NULL` uses a standard 1st
#' or 2nd order (depending on the value of `polyorder`) fractional polynomial model.
#' @param savefile The location of a `.rds` file to which the generated object (a list of models) should be saved. Default (`NULL`) does not
#' save a file.
#' @param overwrite Whether the file specified in `savefile` should be overwritten (`TRUE`), or simply appended (`FALSE`)
#' @param ... Arguments to be sent to JAGS (e.g. `n.iter`)
#' @inheritParams survcalc
#'
#' @return A list of fractional polynomial models. Each element is a model (or an error message if the model failed to
#' run), named as follows `"FP_<1st power>_<2nd power>`.
#'
#' @export
sequence_fpoly <- function(jagsdat, powers=c(-3,-2,-1,-0.5,0,0.5,1,2,3), polyorder=1,
                           jagsfile=NULL, savefile=NULL, overwrite=TRUE,
                           parameters.to.save=c("d", "mu", "dev", "totresdev"),
                           inits=fp_geninits(ns=jagsdat$ns, nt=jagsdat$nt, polyorder=polyorder, seed=890421),
                           ...) {

  args <- list(...)

  # Ensure jagsdat has correct d.mean and prec for polyorder
  if (!all(c("mean", "prec") %in% names(jagsdat))) {
    if (polyorder==1) {
      jagsdat$mean <- c(0,0)
      jagsdat$prec <- array(c(0.0001, 0, 0, 0.0001), dim=c(2,2))
    } else if (polyorder==2){
      jagsdat$mean <- c(0,0,0)
      jagsdat$prec <- array(c(0.0001, 0, 0,
                              0, 0.0001, 0,
                              0, 0, 0.0001), dim=c(3,3))
    }
  }

  # Should previous model file be overwritten or appended?
  if (overwrite==FALSE) {
    if (!is.null(savefile)) {
      modseq <- readRDS(savefile)
    } else {
      modseq <- list()
    }
  } else if (overwrite==TRUE) {
    modseq <- list()
  }

  # 1st order FP
  if (polyorder==1) {
    for (p1 in seq_along(powers)) {

      modnam <- paste("FP", powers[p1], sep="_")

      if (modnam %in% names(modseq) & overwrite==FALSE) {
        #stop("Model run has the same FP powers as an existing model in the list, but overwrite==FALSE")
        print(paste0("Skipping fractional polynomial P1=", powers[p1], ", model ", p1, "/", length(powers)))
      } else {
        print(paste0("Running fractional polynomial P1=", powers[p1], ", model ", p1, "/", length(powers)))

        # Set FP power
        jagsdat$P1 <- powers[p1]


        out <- tryCatch({
          # Run JAGS model
          jagsmod <- do.call(R2jags::jags, c(args, list(data = jagsdat,
                                                        inits=inits,
                                                        parameters.to.save=parameters.to.save,
                                                        model.file=ifelse(!is.null(jagsfile), jagsfile, system.file("JAGSmodels", "FE_1st_order_model.jags", package="BristolTAG"))
                                                        #model.file="inst/JAGSmodels/FE_1st_order_model.jags"
          )))
        },
        error=function(cond) {
          message(cond)
          return(list(error=cond))
        })

        attr(out, "trtnames") <- attr(jagsdat, "trtnames")
        attr(out, "studynames") <- attr(jagsdat, "studynames")
        attr(out, "ipd") <- attr(jagsdat, "ipd")
        modseq[[modnam]] <- out

        if (!is.null(savefile)) {
          saveRDS(modseq, file=savefile)
        }
      }
      }


    # 2nd order FP
  } else if (polyorder==2) {
    count <- 1
    for (p1 in seq_along(powers)) {
      for (p2 in seq_along(powers)) {

        # Calculate permutations of powers
        perm <- factorial(length(powers)) / factorial(length(powers)-2)

        # Check model name
        modnam <- paste("FP", powers[p1], powers[p2], sep="_")

        if (modnam %in% names(modseq) & overwrite==FALSE) {
          #stop("Model run has the same FP powers as an existing model in the list, but overwrite==FALSE")
          print(paste0("Skipping fractional polynomial P1=", powers[p1], ", P2=", powers[p2],
                       ", model ", count, "/", perm))
          count <- count + 1

        } else {
          print(paste0("Running fractional polynomial P1=", powers[p1], ", P2=", powers[p2],
                       ", model ", count, "/", perm))
          count <- count + 1

          # Set FP power
          jagsdat$P1 <- powers[p1]
          jagsdat$P2 <- powers[p2]


          out <- tryCatch({
            # Run JAGS model
            jagsmod <- do.call(R2jags::jags, c(args, list(data = jagsdat,
                                                          inits=inits,
                                                          parameters.to.save=parameters.to.save,
                                                          model.file=ifelse(!is.null(jagsfile), jagsfile, system.file("JAGSmodels", "FE_2nd_order_model.jags", package="BristolTAG"))
            )))
          },
          error=function(cond) {
            message(cond)
            return(list(error=cond))
          })

          attr(out, "trtnames") <- attr(jagsdat, "trtnames")
          attr(out, "studynames") <- attr(jagsdat, "studynames")
          attr(out, "ipd") <- attr(jagsdat, "ipd")
          modseq[[modnam]] <- out

          if (!is.null(savefile) & !("error" %in% names(out))) {
            saveRDS(modseq, file=savefile)
          }
        }
      }
    }
  }

  # attributes(modseq)$trtnames <- attributes(jagsdat)$trtnames
  # attributes(modseq)$studynames <- attributes(jagsdat)$studynames

  class(modseq) <- "sequence.fpoly"
  return(modseq)
}





#' Get a summary of model fit statistics for a sequence of models
#'
#' @param object A list of JAGS models of class `"sequence.fpoly` generated by `sequence_fpoly()`
#' @param rhat A cutoff for which to make a basic check for convergence. If there are any `mu` or `d`
#' parameters that have an Rhat greater than this cutoff (default is 1.05) then it will be announced. Can set to
#' `NULL` which means a convergence check won't be made (and therefore you should do it yourself properly :-P).
#' @param ... Arguments for `tibble()`
#'
#' @return Returns a tibble of model fit stats. If values are `NA` for a model then it means the model did not run and
#' returned an error.
#'
#' @export
#'
summary.sequence.fpoly <- function(object, rhat=1.05, ...) {

  if (!class(object) %in% "sequence.fpoly") {
    stop("object must be an object of class 'sequence.fpoly' generated by sequence_fpoly()")
  }

  out.df <- dplyr::tibble("model"=NA, "totresdev"=NA, "pv"=NA, "DIC"=NA, converged=NA, ...)

  for (mod in seq_along(object)) {

    # If a model threw an error
    if ("error" %in% names(object[[mod]])) {
      out.df <- out.df %>% dplyr::add_row(model=names(object)[mod],
                                   totresdev=NA,
                                   pv=NA,
                                   DIC=NA,
                                   converged=NA
      )
    } else {

      # Convergence check
      ind <- grep("d\\[", rownames(object[[mod]]$BUGSoutput$summary))
      ind <- append(ind, grep("mu\\[", rownames(object[[mod]]$BUGSoutput$summary)))
      con <- all(object[[mod]]$BUGSoutput$summary[ind, "Rhat"]<rhat)

      out.df <- out.df %>% dplyr::add_row(model=names(object)[mod],
                                   totresdev=round(mean(object[[mod]]$BUGSoutput$mean$totresdev),2),
                                   pv=round(object[[mod]]$BUGSoutput$pD,2),
                                   DIC=round(object[[mod]]$BUGSoutput$DIC,2),
                                   converged=con
      )

    }
  }
  out.df <- out.df[-1,]

  # Add FP powers
  if (class(object) %in% "sequence.fpoly") {
    out.df$P1 <- as.numeric(sapply(out.df$model, FUN=function(x) strsplit(x, "_")[[1]][2]))
    out.df$P2 <- as.numeric(sapply(out.df$model, FUN=function(x) strsplit(x, "_")[[1]][3]))

    out.df <- out.df[,c("model", "P1", "P2", "totresdev", "pv", "DIC", "converged")]
  }

  return(out.df)
}





#' Calculate Area Under the Curve
#'
#' @param surv An object of class `"surv.predicts"` generated by `survcalc()`.
#' @param tint A numeric vector of length 2 that indicates the interval over which to
#'   calculate AUC.
#' @inheritParams plot.surv.predicts
#'
#' @return Returns a data frame of AUC values for each treatment
#'
#' @details
#' Function uses the `pracma` package for integration, so this must be installed.
#'
#' @export
auc <- function(surv, tint=c(1,max(surv[[1]]$time)),
                              quantity="S"
                              ) {

  if (!"surv.predicts" %in% class(surv)) {
    stop("surv must be an object of class 'surv.predicts' generated by survcalc()")
  }
  if (length(tint)!=2) {
    stop("tint must have length 2")
  }

  sum.df <- surv[[quantity]]

  sum.df <- subset(sum.df, time>=tint[1] & time<=tint[2])

  # Uses the pracma package
  sum.df <- sum.df %>% dplyr::group_by(treatment) %>%
    dplyr::mutate(auc=pracma::trapz(time, `50%`)) %>%
    dplyr::select(treatment, auc) %>%
    unique(.)

  return(sum.df)
}





#' Create log-log plots
#'
#' Used to assess the validity of the proportional hazards assumption
#'
#' @inheritParams anova_data
#'
#' @export
loglog_plot <- function(df) {

  KM.est <- survival::survfit(Surv(time, event) ~ treatment + study, data=df, type="kaplan-meier")

  # Extract treatments from KM strata
  treats <- KM.est$strata
  names(treats) <- trimws(gsub("(treatment=)(.+)(, study.+)", "\\2", names(KM.est$strata)), "right")

  # Extract studies from KM strata
  studies <- KM.est$strata
  names(studies) <- trimws(gsub("(treatment=.+, study=)(.+$)", "\\2", names(KM.est$strata)), "right")

  # Create data for plotting
  plot.df <- data.frame(x=log(KM.est$time), y=-log(-log(KM.est$surv)),
                        treatment=factor(rep(names(treats), times=treats)),
                        study=factor(rep(names(studies), times=studies)))

  cols <- RColorBrewer::brewer.pal(dplyr::n_distinct(plot.df$treatment), "Set1")

  g <- ggplot2::ggplot(plot.df, ggplot2::aes(x=x, y=y, color=treatment)) +
    ggplot2::geom_line(linewidth=1) +
    ggplot2::facet_wrap(~study, scales="free") +
    ggplot2::xlab("ln(time)") + ggplot2::ylab("-ln(-ln(S))") +
    ggplot2::scale_color_manual(values=cols, name="Treatment") +
    #ggplot2::scale_linetype_manual(name="Treatment", values=1:length(cols)) +
    ggplot2::theme_bw()

  return(g)
}








#' Get fractional polynomial parameters
#'
#' @param x A vector with the dependent variable (time).
#' @param params A matrix with 2-3 columns (depending on the fractional polynomial order)
#'   giving the intercept and the "slope". If more than one rows given, the fractional polynomial
#'   is evaluated for each row.
#' @param exponent A vector of integers giving the exponent(s) (p1 or c(p1,p2)) of the polynomial.
#'
#' @details
#' Function copied and edited from gemtcPlus (https://github.com/Roche/gemtcPlus/tree/main)
#'
#' @return A matrix with length(x) rows giving the FP values or FP summaries.
#' @export
#'
get_fp <- function(x, params, exponents, sums=NULL){

  # 1st order
  if (length(exponents)==1) {
    if (exponents == 0){
      xt <- log(x)
    } else {
      xt <- x^exponents
    }

    X <- cbind(1, xt)

  # 2nd order
  } else if (length(exponents)==2) {

    if (exponents[1] == 0){
      xt1 <- log(x)
    } else {
      xt1 <- x^exponents[1]
    }
    if (exponents[1] != exponents[2]){
      if (exponents[2] == 0){
        xt2 <- log(x)
      } else {
        xt2 <- x^exponents[2]
      }
    } else {
      if (exponents[2] == 0){
        xt2 <- log(x)^2
      } else {
        xt2 <- x^exponents[2] * log(x)
      }
    }

    X <- cbind(1, xt1, xt2)

  } else {
    stop("exponents must be length 1 or 2 for 1st and 2nd order models respectively")
  }

  if (is.vector(params)) {
    params <- matrix(params, ncol = 1)
  }
  if (dim(X)[2] != dim(params)[1]){
    params <- t(params)
  }

  out <- X %*% params

  return(out)
}



